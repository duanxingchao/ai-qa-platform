# 🔌 端口配置优化方案

## 📋 **当前端口风险分析**

### **高风险端口 (必须修改)**
```bash
80   - HTTP   (几乎100%冲突，被Nginx/Apache占用)
443  - HTTPS  (几乎100%冲突，被Web服务器占用)
```

### **中等风险端口 (建议修改)**
```bash
6379 - Redis      (可能与公司Redis冲突)
9090 - Prometheus (可能与监控服务冲突)
```

### **低风险端口 (相对安全)**
```bash
8088 - 后端API (相对安全，但建议检查)
```

## 🎯 **推荐的端口配置方案**

### **方案一：企业标准端口 (推荐)**
```yaml
服务配置：
├── 前端HTTP:   18080  (18xxx系列，避免常用端口)
├── 前端HTTPS:  18443  (对应HTTPS)
├── 后端API:    18088  (保持8088风格，加前缀)
├── Redis:      16379  (保持6379风格，加前缀)
└── Prometheus: 19090  (保持9090风格，加前缀)
```

### **方案二：高端口段 (最安全)**
```yaml
服务配置：
├── 前端HTTP:   28080  (28xxx系列)
├── 前端HTTPS:  28443
├── 后端API:    28088
├── Redis:      26379
└── Prometheus: 29090
```

### **方案三：项目专用端口段**
```yaml
服务配置：
├── 前端HTTP:   30080  (30xxx系列，专用于AI问答系统)
├── 前端HTTPS:  30443
├── 后端API:    30088
├── Redis:      30379
└── Prometheus: 30090
```

## 🔍 **端口冲突检查脚本**

### **检查当前端口占用**
```bash
#!/bin/bash
echo "=== 端口占用检查 ==="

ports=(80 443 6379 8088 9090 18080 18443 18088 16379 19090)

for port in "${ports[@]}"; do
    if netstat -tuln 2>/dev/null | grep -q ":$port "; then
        echo "❌ 端口 $port 已被占用"
        process=$(sudo netstat -tulnp 2>/dev/null | grep ":$port " | awk '{print $7}' | head -1)
        echo "   占用进程: $process"
    else
        echo "✅ 端口 $port 可用"
    fi
done
```

### **推荐端口可用性检查**
```bash
#!/bin/bash
echo "=== 推荐端口检查 ==="

recommended_ports=(18080 18443 18088 16379 19090)

for port in "${recommended_ports[@]}"; do
    if netstat -tuln 2>/dev/null | grep -q ":$port "; then
        echo "⚠️ 推荐端口 $port 已被占用"
    else
        echo "✅ 推荐端口 $port 可用"
    fi
done
```

## 📝 **Docker Compose端口配置模板**

### **企业标准端口配置**
```yaml
version: '3.7'

services:
  backend:
    ports:
      - "18088:8088"  # 外部18088 -> 容器内8088
    
  frontend:
    ports:
      - "18080:80"    # 外部18080 -> 容器内80
      - "18443:443"   # 外部18443 -> 容器内443
    
  redis:
    ports:
      - "16379:6379"  # 外部16379 -> 容器内6379
    
  prometheus:
    ports:
      - "19090:9090"  # 外部19090 -> 容器内9090
```

### **高端口段配置**
```yaml
version: '3.7'

services:
  backend:
    ports:
      - "28088:8088"
    
  frontend:
    ports:
      - "28080:80"
      - "28443:443"
    
  redis:
    ports:
      - "26379:6379"
    
  prometheus:
    ports:
      - "29090:9090"
```

## 🚀 **端口配置实施步骤**

### **步骤1: 检查端口占用**
```bash
# 运行端口检查脚本
chmod +x check-ports.sh
./check-ports.sh
```

### **步骤2: 选择端口方案**
根据检查结果选择合适的端口方案

### **步骤3: 修改配置文件**
```bash
# 备份原配置
cp docker-compose.ubuntu18.yml docker-compose.ubuntu18.yml.backup

# 应用新端口配置
# (使用提供的配置模板)
```

### **步骤4: 更新环境变量**
```bash
# 更新.env文件中的端口配置
FRONTEND_PORT=18080
FRONTEND_HTTPS_PORT=18443
BACKEND_PORT=18088
REDIS_PORT=16379
PROMETHEUS_PORT=19090
```

### **步骤5: 更新防火墙规则**
```bash
# 开放新端口
sudo ufw allow 18080
sudo ufw allow 18443
sudo ufw allow 18088
sudo ufw allow 16379
sudo ufw allow 19090
```

## 🔧 **Nginx反向代理配置 (可选)**

如果公司已有Nginx，可以配置反向代理：

```nginx
# /etc/nginx/sites-available/ai-qa-platform
server {
    listen 80;
    server_name ai-qa-platform.company.com;
    
    # 前端代理
    location / {
        proxy_pass http://localhost:18080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    
    # 后端API代理
    location /api/ {
        proxy_pass http://localhost:18088;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

## 📊 **端口管理最佳实践**

### **企业环境建议**
1. **使用高端口段** (10000+) 避免系统端口冲突
2. **统一端口前缀** (如18xxx) 便于管理
3. **文档化端口使用** 避免团队内冲突
4. **预留端口范围** 为扩展留出空间

### **端口分配策略**
```bash
项目端口分配：
├── AI问答系统:     18xxx (18080-18099)
├── 其他项目A:      19xxx (19080-19099)
├── 其他项目B:      20xxx (20080-20099)
└── 监控服务:       21xxx (21080-21099)
```

### **安全考虑**
1. **内部端口** 仅在内网开放
2. **外部访问** 通过反向代理
3. **防火墙规则** 限制端口访问
4. **监控告警** 端口异常访问

## ✅ **推荐实施方案**

**对于您的项目，我推荐：**

1. **立即实施** - 企业标准端口方案 (18xxx系列)
2. **原因**：
   - ✅ 避免与常用服务冲突
   - ✅ 保持端口逻辑性
   - ✅ 便于记忆和管理
   - ✅ 符合企业环境规范

3. **访问地址变更**：
   - 前端: `http://服务器IP:18080`
   - 后端API: `http://服务器IP:18088`
   - 监控: `http://服务器IP:19090`

这样既避免了端口冲突，又保持了系统的专业性和可维护性。
